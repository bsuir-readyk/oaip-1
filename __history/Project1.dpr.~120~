program SolveExpression;

{$APPTYPE CONSOLE}
// y=f(x)
// x = [a..h..b]
// y = (abs(ln(x²)) + 2 + 1 / 5) / (ℯ^(x / π) + nroot(x² + 1,3) + 1 + 1 / 4)

uses
  SysUtils;

// micro-functions
function CubicRoot(Value: Single): Single; inline;
begin
  Result := Exp(Ln(Value) / 3);
end;

function Min(a: Single; b: Single): Single;
begin
  if a >= b then
    Result := b
  else
    Result := a;
end;

function Max(a: Single; b: Single): Single;
begin
  if a >= b then
    Result := a
  else
    Result := b;
end;

function CompGreater(a: Single; b: Single): Boolean; inline;
begin
  CompGreater := a > b
end;

function CompLower(a: Single; b: Single): Boolean; inline;
begin
  CompLower := a < b
end;

// helpers
procedure LogResult(x: Single; y: Single; error: String); inline;
begin
  if error <> '' then
    WriteLn(Format('%8.3f %-s', [x, error]))
  else
    WriteLn(Format('%8.3f %-15.4g', [x, y]));
end;

procedure RepeatedReadTo(var readTo: Single; gentleInput: String = '');
var
  error: String;
begin
  repeat
  begin
    error := '';
    Write(gentleInput);
    try
      ReadLn(readTo);
    except
      on E: Exception do
      begin
        error := E.Message;
        WriteLn(error);
      end;
    end;
  end;
  until error = '';
end;

// math solution
function Compute(x: Single; out error: String): Single;
var
  numerator, denominator: Single;
begin
  WriteLn(Abs(x), 1 / 1e9);
  if Abs(x) < 1 / 1e9 then
  begin
    error := 'функция не определена';
    Result := MaxInt;
    // early return would be awesome
  end
  else
  begin
    numerator := abs(Ln(x * x)) + 2.2;
    denominator := Exp(x / Pi) + CubicRoot(x * x + 1) + 1.25;

    error := '';
    Result := numerator / denominator;
  end;
end;

// main
var
  comparator: function(a: Single; b: Single): Boolean;
  error: String;
  needCycle: Boolean;
  a, b, h, x, finish, ans: Single;

begin
  error := '';
  needCycle := true;

  RepeatedReadTo(a, 'a: ');
  RepeatedReadTo(b, 'b: ');
  RepeatedReadTo(h, 'h: ');

  WriteLn('   x     y');

  ans := Compute(a, error);
  LogResult(a, ans, error);

  needCycle := not (
    (h = 0)
    or (a = b)
    or ((b > a) and (h < 0))
    or ((b < a) and (h > 0))
  );

  if needCycle then
  begin
    // check if step is above 0
    if h > 0 then
    begin
      x := Min(a, b);
      finish := Max(a, b);
      comparator := CompLower;
    end
    else
    begin
      x := Max(a, b);
      finish := Min(a, b);
      comparator := CompGreater;
    end;

    // computations
    x := x + h;
    while comparator(x, finish) do
    begin
      ans := Compute(x, error);
      LogResult(x, ans, error);

      x := x + h;
    end;
  end;

  // log finish result if neeeded
  if (
    needCycle
    or (not needCycle and (Abs(a - b) > (1 / 1e9)))
  ) then
  begin
    ans := Compute(b, error);
    LogResult(b, ans, error);
  end;

  ReadLn;
end.

